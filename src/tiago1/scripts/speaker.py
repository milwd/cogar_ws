#! /usr/bin/env python
"""
speaker.py
==========

Last-mile **speech relay** – pushes text from the planning layer to the
audio driver
-----------------------------------------------------------------------

The cognitive stack already decided *what* the robot should say and placed the
sentence on ``/speaker_channel``.  **speaker.py** simply republishes that text
to ``/speaker_output``, the topic consumed by whatever TTS backend (sound_play,
Festival, external loud-speaker node) is active.

ROS interface
~~~~~~~~~~~~~
.. list-table::
   :header-rows: 1
   :widths: 25 35 40

   * - Direction / type
     - Name
     - Semantics
   * - **subscribe** ``std_msgs/String``
     - ``/speaker_channel``
     - High-level sentences generated by the cognitive layer
   * - **publish** ``std_msgs/String``
     - ``/speaker_output``
     - Identical text, ready for the TTS node

Design notes
------------
* **Stateless** – no transformation, just one-to-one forwarding.  
* **Latch** – publisher is *latched* (`queue_size=10, latch=True`) so late TTS
  subscribers still receive the most recent sentence.  
* **Rate-free** – message is forwarded immediately within the subscriber
  callback; a separate loop is unnecessary.

"""

import rospy
from std_msgs.msg import String
import sys



class Speaker:
    """
    Thin ROS node that forwards the latest sentence to the output topic.

    Instance Variables
    ------------------
    msg
        Most recent :pyclass:`std_msgs.msg.String` received on
        ``/speaker_channel``; *None* until the first message arrives.
    pub_speak
        :pyclass:`rospy.Publisher` that republishes :pyattr:`msg` on
        ``/speaker_output`` with *latching* enabled.
    """

    def __init__(self):
        """
        Initialize the Speaker node:

        - Initialize ROS node 'speaker_node'.
        - Subscribe to '/speaker_channel' for intermediate speech commands.
        - Advertise '/speaker_output' for the final spoken output.
        """
        self.robot_number = sys.argv[1]#rospy.get_param('~robot_number')
        rospy.init_node(f'{self.robot_number}_speaker_node')
        self.msg = None
        rospy.Subscriber(f'/{self.robot_number}/speaker_channel',String, self.speaker_callback)
        self.pub_speak = rospy.Publisher(f'/{self.robot_number}/speaker_output',String,queue_size=10)
        
    def speaker_callback(self, msg):
        """
        Callback invoked when a new speech command arrives.
        """
        self.msg: String | None = None

        rospy.Subscriber('/speaker_channel',
                         String,
                         self.speaker_callback,
                         queue_size=10)

        self.pub_speak = rospy.Publisher('/speaker_output',
                                         String,
                                         queue_size=10,
                                         latch=True)

        rospy.loginfo("[Speaker] Node ready – waiting for sentences.")

    # ------------------------------------------------------------------ #
    #                           callback                                  #
    # ------------------------------------------------------------------ #
    def speaker_callback(self, msg: String) -> None:
        """
        Store *msg* and forward it to ``/speaker_output`` immediately.
        """
        self.msg = msg
        self.pub_speak.publish(msg)
        rospy.loginfo(f"[Speaker] Relayed: {msg.data!r}")


# ---------------------------------------------------------------------- #
#                               bootstrap                                #
# ---------------------------------------------------------------------- #
if __name__ == "__main__":
    try:
        Speaker()
        rospy.spin()                      # no manual loop required
    except rospy.ROSInterruptException:
        pass
