#!/usr/bin/env python
import rospy
import actionlib
from geometry_msgs.msg import Twist
from nav_msgs.msg import Path, OccupancyGrid, Odometry
from geometry_msgs.msg import PoseStamped
from tiago1.msg import MovementControlAction, MovementControlFeedback, MovementControlResult

class ControlMovementServer:
    def __init__(self):
        self.cmd_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        self.server = actionlib.SimpleActionServer(
            'movement_control',
            MovementControlAction,
            execute_cb=self.execute_cb,
            auto_start=False
        )
        self.server.start()
        rospy.loginfo("[ControlMovement] Action server started")

    def execute_cb(self, path):
        feedback = MovementControlFeedback()
        result = MovementControlResult()

        rospy.loginfo(f"[ControlMovement] Received path with {len(path.poses)} points")

        if self.server.is_preempt_requested():
            rospy.logwarn("[ControlMovement] Preempted")
            self.server.set_preempted()
            return

        # silly p-controller
        cmd = Twist()
        cmd.linear.x = path.poses[0].pose.x * 0.01  
        cmd.linear.y = path.poses[0].pose.y * 0.01
        self.cmd_pub.publish(cmd)

        feedback.status = f"Moving to point {1}/{len(path.poses)}"
        self.server.publish_feedback(feedback)
        rospy.sleep(2)  # time to reach each point

        result.success = True
        self.server.set_succeeded(result)

if __name__ == '__main__':
    rospy.init_node('control_movement_node')
    ControlMovementServer()
    rospy.spin()
